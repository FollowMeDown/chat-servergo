/*
 *  Copyright (c) 2017, https://github.com/nebulaim
 *  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdlib.h>
#include <algorithm>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <openssl/bn.h>
#include <openssl/pem.h>
#include <openssl/aes.h>
#include <memory.h>
#include <iostream>
#include <vector>

// The following was auto-generated by
//  openssl dhparam -C 2048 with OepnSSL 1.1.0e

static unsigned char dh2048_p[] = {
    0x8B,0xFE,0x29,0x76,0x8B,0xD9,0xA4,0x53,0xA4,0xEA,0x97,0x99,
    0xF7,0xC6,0x23,0x1D,0xDF,0x5B,0xE2,0x94,0xE3,0x07,0xE7,0xF1,
    0x13,0xAA,0x9D,0xCF,0x43,0x3C,0xD9,0xE5,0xF3,0x46,0xD6,0x4E,
    0x60,0x66,0x55,0x1C,0xE8,0xE6,0x67,0xB5,0xCA,0x13,0x76,0xEB,
    0xD4,0x5C,0x8F,0x7A,0x5D,0xB9,0x7A,0xA3,0xA5,0x6E,0xF4,0xFA,
    0xF2,0xD2,0x4E,0xC3,0x65,0x61,0xE6,0x98,0x1F,0xB2,0x61,0xE1,
    0x0D,0x4E,0xD5,0x77,0x31,0x11,0xA2,0xD3,0xEE,0x9E,0xA0,0x2C,
    0x44,0xD6,0x46,0xFC,0x80,0x03,0x62,0xFF,0x7E,0xF9,0x40,0xAD,
    0x5C,0xC4,0x88,0x7D,0xAD,0x61,0x4E,0x14,0x68,0x1B,0x8F,0x78,
    0x0E,0x6B,0x8C,0x11,0xD0,0x9B,0x38,0xA6,0x57,0x94,0x51,0x0B,
    0x7C,0x90,0x17,0x5A,0xB2,0x43,0xB8,0x18,0x06,0xA6,0x90,0x60,
    0xC0,0x72,0x9F,0xE9,0x0B,0xB8,0x5C,0x95,0x8B,0xB8,0xE5,0x30,
    0x6C,0x61,0xCB,0x42,0xE5,0x0A,0x8E,0x73,0x16,0x31,0x6B,0xF8,
    0xAD,0x85,0xF5,0xC9,0xC4,0x2A,0x4B,0xCC,0xAB,0x3C,0x77,0x7D,
    0x4F,0x94,0x30,0x58,0x63,0xFA,0x7F,0x29,0xF0,0xA8,0x43,0xD1,
    0x38,0x72,0xCF,0x8D,0x4C,0x00,0x3E,0xBC,0x6A,0x40,0x8C,0x8C,
    0x0D,0x00,0x69,0xB1,0xF3,0xA1,0x1B,0x97,0xA3,0x18,0x0E,0x44,
    0x41,0xF3,0xAB,0x36,0x1B,0xAC,0xBA,0x85,0x7D,0x15,0x28,0x81,
    0xC9,0xFC,0xEE,0x75,0x92,0x1F,0x64,0xE0,0x5A,0x79,0x28,0x8E,
    0x57,0xFC,0xC3,0x9D,0x71,0xE8,0xC2,0x1F,0x67,0x9F,0xD0,0xE3,
    0x68,0x8E,0x0B,0x50,0xDA,0xD8,0x93,0xBF,0x26,0xC7,0x8E,0x52,
    0xC3,0x16,0xD1,0x33,
};

static unsigned char dh2048_g[] = {
    0x02,
};

// andriod client
// static const char *goodPrime = "c71caeb9c6b1c9048e6c522f70f13f73980d40238e3e21c14934d037563d930f48198a0aa7c14058229493d22530f4dbfa336f6e0ac925139543aed44cce7c3720fd51f69458705ac68cd4fe6b6b13abdc9746512969328454f18faf8c595f642477fe96bb2a941d5bcd1d4ac8cc49880708fa9b378e3c4f3a9060bee67cf9a4a4a695811051907e162753b56b0f6b410dba74d8a84b2a14b3144e0ef1284754fd17ed950d5965b4b9dd46582db1178d169c6bc465b0d6ff9ca3928fef5b9ae4e418fc15e83ebea0f87fa9ff5eed70050ded2849f47bf959d956850ce929851f0d8115f635b105ee2e4e15d04b2454bf6f4fadf034b10403119cd8e3b92fcc5b";
//
static unsigned char kDH2048P[] = {
    0xc7, 0x1c, 0xae, 0xb9, 0xc6, 0xb1, 0xc9, 0x04, 0x8e, 0x6c, 0x52, 0x2f,
    0x70, 0xf1, 0x3f, 0x73, 0x98, 0x0d, 0x40, 0x23, 0x8e, 0x3e, 0x21, 0xc1,
    0x49, 0x34, 0xd0, 0x37, 0x56, 0x3d, 0x93, 0x0f, 0x48, 0x19, 0x8a, 0x0a,
    0xa7, 0xc1, 0x40, 0x58, 0x22, 0x94, 0x93, 0xd2, 0x25, 0x30, 0xf4, 0xdb,
    0xfa, 0x33, 0x6f, 0x6e, 0x0a, 0xc9, 0x25, 0x13, 0x95, 0x43, 0xae, 0xd4,
    0x4c, 0xce, 0x7c, 0x37, 0x20, 0xfd, 0x51, 0xf6, 0x94, 0x58, 0x70, 0x5a,
    0xc6, 0x8c, 0xd4, 0xfe, 0x6b, 0x6b, 0x13, 0xab, 0xdc, 0x97, 0x46, 0x51,
    0x29, 0x69, 0x32, 0x84, 0x54, 0xf1, 0x8f, 0xaf, 0x8c, 0x59, 0x5f, 0x64,
    0x24, 0x77, 0xfe, 0x96, 0xbb, 0x2a, 0x94, 0x1d, 0x5b, 0xcd, 0x1d, 0x4a,
    0xc8, 0xcc, 0x49, 0x88, 0x07, 0x08, 0xfa, 0x9b, 0x37, 0x8e, 0x3c, 0x4f,
    0x3a, 0x90, 0x60, 0xbe, 0xe6, 0x7c, 0xf9, 0xa4, 0xa4, 0xa6, 0x95, 0x81,
    0x10, 0x51, 0x90, 0x7e, 0x16, 0x27, 0x53, 0xb5, 0x6b, 0x0f, 0x6b, 0x41,
    0x0d, 0xba, 0x74, 0xd8, 0xa8, 0x4b, 0x2a, 0x14, 0xb3, 0x14, 0x4e, 0x0e,
    0xf1, 0x28, 0x47, 0x54, 0xfd, 0x17, 0xed, 0x95, 0x0d, 0x59, 0x65, 0xb4,
    0xb9, 0xdd, 0x46, 0x58, 0x2d, 0xb1, 0x17, 0x8d, 0x16, 0x9c, 0x6b, 0xc4,
    0x65, 0xb0, 0xd6, 0xff, 0x9c, 0xa3, 0x92, 0x8f, 0xef, 0x5b, 0x9a, 0xe4,
    0xe4, 0x18, 0xfc, 0x15, 0xe8, 0x3e, 0xbe, 0xa0, 0xf8, 0x7f, 0xa9, 0xff,
    0x5e, 0xed, 0x70, 0x05, 0x0d, 0xed, 0x28, 0x49, 0xf4, 0x7b, 0xf9, 0x59,
    0xd9, 0x56, 0x85, 0x0c, 0xe9, 0x29, 0x85, 0x1f, 0x0d, 0x81, 0x15, 0xf6,
    0x35, 0xb1, 0x05, 0xee, 0x2e, 0x4e, 0x15, 0xd0, 0x4b, 0x24, 0x54, 0xbf,
    0x6f, 0x4f, 0xad, 0xf0, 0x34, 0xb1, 0x04, 0x03, 0x11, 0x9c, 0xd8, 0xe3,
    0xb9, 0x2f, 0xcc, 0x5b,
};

static unsigned int kDH2048G[] = {0x02};


static unsigned char pq[] = {0x17, 0xED, 0x48, 0x94, 0x1A, 0x08, 0xF9, 0x81};
/*
 //TODO run in different thread?
 uint64_t pq = ((uint64_t) (result->pq->bytes[0] & 0xff) << 56) |
               ((uint64_t) (result->pq->bytes[1] & 0xff) << 48) |
               ((uint64_t) (result->pq->bytes[2] & 0xff) << 40) |
               ((uint64_t) (result->pq->bytes[3] & 0xff) << 32) |
               ((uint64_t) (result->pq->bytes[4] & 0xff) << 24) |
               ((uint64_t) (result->pq->bytes[5] & 0xff) << 16) |
               ((uint64_t) (result->pq->bytes[6] & 0xff) << 8) |
               ((uint64_t) (result->pq->bytes[7] & 0xff));
 */

static unsigned char p[] = {0x49, 0x4C, 0x55, 0x3B};
static unsigned char q[] = {0x53, 0x91, 0x10, 0x73};

int BN_primality_test(int *is_probably_prime, const BIGNUM *candidate,
                      int checks, BN_CTX *ctx, int do_trial_division,
                      BN_GENCB *cb) {
  switch (BN_is_prime_fasttest_ex(candidate, checks, ctx, do_trial_division, cb)) {
    case 1:
      *is_probably_prime = 1;
      return 1;
    case 0:
      *is_probably_prime = 0;
      return 1;
    default:
      *is_probably_prime = 0;
      return 0;
  }
}

static BN_CTX *bnContext = nullptr;

inline bool check_prime(BIGNUM *p) {
    int result = 0;
    if (!BN_primality_test(&result, p, BN_prime_checks, bnContext, 0, NULL)) {
        std::cerr << "OpenSSL error at BN_primality_test" << std::endl;
        return false;
    }
    return result != 0;
}

inline bool isGoodPrime(BIGNUM *p, uint32_t g) {
    //TODO check against known good primes
    if (g < 2 || g > 7 || BN_num_bits(p) != 2048) {
        return false;
    }

    BIGNUM *t = BN_new();
    BIGNUM *dh_g = BN_new();

    if (!BN_set_word(dh_g, 4 * g)) {
        std::cerr << "OpenSSL error at BN_set_word(dh_g, 4 * g)" << std::endl;
        BN_free(t);
        BN_free(dh_g);
        return false;
    }
    if (!BN_mod(t, p, dh_g, bnContext)) {
        std::cerr << "OpenSSL error at BN_mod";
        BN_free(t);
        BN_free(dh_g);
        return false;
    }
    uint64_t x = BN_get_word(t);
    if (x >= 4 * g) {
        std::cerr << "OpenSSL error at BN_get_word" << std::endl;
        BN_free(t);
        BN_free(dh_g);
        return false;
    }

    std::cout << "x = " << x << std::endl;
    BN_free(dh_g);

    bool result = true;
    switch (g) {
        case 2:
            if (x != 7) {
                result = false;
            }
            break;
        case 3:
            if (x % 3 != 2) {
                result = false;
            }
            break;
        case 5:
            if (x % 5 != 1 && x % 5 != 4) {
                result = false;
            }
            break;
        case 6:
            if (x != 19 && x != 23) {
                result = false;
            }
            break;
        case 7:
            if (x % 7 != 3 && x % 7 != 5 && x % 7 != 6) {
                result = false;
            }
            break;
        default:
            break;
    }

    char *prime = BN_bn2hex(p);
    static const char *goodPrime = "c71caeb9c6b1c9048e6c522f70f13f73980d40238e3e21c14934d037563d930f48198a0aa7c14058229493d22530f4dbfa336f6e0ac925139543aed44cce7c3720fd51f69458705ac68cd4fe6b6b13abdc9746512969328454f18faf8c595f642477fe96bb2a941d5bcd1d4ac8cc49880708fa9b378e3c4f3a9060bee67cf9a4a4a695811051907e162753b56b0f6b410dba74d8a84b2a14b3144e0ef1284754fd17ed950d5965b4b9dd46582db1178d169c6bc465b0d6ff9ca3928fef5b9ae4e418fc15e83ebea0f87fa9ff5eed70050ded2849f47bf959d956850ce929851f0d8115f635b105ee2e4e15d04b2454bf6f4fadf034b10403119cd8e3b92fcc5b";
    if (!strcasecmp(prime, goodPrime)) {
        delete [] prime;
        BN_free(t);
        return true;
    }
    delete [] prime;

    if (!result || !check_prime(p)) {
        BN_free(t);
        return false;
    }

    BIGNUM *b = BN_new();
    if (!BN_set_word(b, 2)) {
        std::cerr << "OpenSSL error at BN_set_word(b, 2)" << std::endl;
        BN_free(b);
        BN_free(t);
        return false;
    }
    if (!BN_div(t, 0, p, b, bnContext)) {
        std::cerr << "OpenSSL error at BN_div" << std::endl;
        BN_free(b);
        BN_free(t);
        return false;
    }
    if (!check_prime(t)) {
        result = false;
    }
    BN_free(b);
    BN_free(t);
    return result;
}

inline bool isGoodGaAndGb(BIGNUM *g_a, BIGNUM *p) {
    if (BN_num_bytes(g_a) > 256 || BN_num_bits(g_a) < 2048 - 64 || BN_cmp(p, g_a) <= 0) {
        return false;
    }
    BIGNUM *dif = BN_new();
    BN_sub(dif, p, g_a);
    if (BN_num_bits(dif) < 2048 - 64) {
        BN_free(dif);
        return false;
    }
    BN_free(dif);
    return true;
}

// PEM_read_bio_RSAPublicKey(BIO_new_mem_buf(const_cast<gsl::byte*>(key.data()), key.size()), 0, 0, 0))
//	{
//		if (_rsa) {
//			computeFingerprint();
//		}
//	}

// 测试公钥证书
//static const std::string g_test_public_key =
//    "-----BEGIN RSA PUBLIC KEY-----\n"
//    "MIIBCgKCAQEAtUXgOV7DZ1d9M08gYVOMU/fenTbbLU12b1LoL9sYfRycEpF4aqA9\n"
//    "RW0rPfzY6yZkfTlQdoFaGxVpUiNMv5V3xY+aVoFQbT7rlsevE87tHK90yG1OYysl\n"
//    "V7IJiCy/tLu/2DVhbZqg4fgPjs4XYrt7CABmsy/OtHJy6A9I1qPQ40MlSB21lmAQ\n"
//    "I9gKHBc2BGZCvQ/NDj1elun9Qitf3ziH8g/Xsxv18CO8hAev56FUMIFzMtGOmhpJ\n"
//    "DAkQ+zg22yLlxKuxjkWSEkYYzHgzrCiDfqcfSkG34veRdD9CGnLsIPvHtTFV/+b0\n"
//    "5xTUyQxFzZ3kOl41KsTY9OsebYxYThHbTQIDAQAB\n"
//    "-----END RSA PUBLIC KEY-----\n";

void PringHex(unsigned char* b, int l) {
  // std::string out;
  for (int i=0; i < l ; ++i) {
    printf("%02X", b[i]);
  }
  printf("\n");
}

void WriteString(const unsigned char* data, int data_len, std::vector<unsigned char>& obuf) {
	uint32_t l = data_len, s = l + ((l < 254) ? 1 : 4), was = obuf.size();
	std::cout << "l ==> " << l << std::endl;
	std::cout << "s ==> " << s << std::endl;
	if (s & 0x03) {
		s += 4;
	}
	// s >>= 2;
	std::cout << "s ==> " << s << std::endl;

	obuf.resize(was + s);
	char *buf = (char*)&obuf[was];
	if (l < 254) {
		unsigned char sl = (unsigned char)l;
		*(buf++) = *(unsigned char*)(&sl);
	} else {
		*(buf++) = (unsigned char)254;
		*(buf++) = (unsigned char)(l & 0xFF);
		*(buf++) = (unsigned char)((l >> 8) & 0xFF);
		*(buf++) = (unsigned char)((l >> 16) & 0xFF);
	}
	memcpy(buf, data, l);
	PringHex(obuf.data()+was, s);
}

static const std::string g_test_public_key =
    "-----BEGIN RSA PUBLIC KEY-----\n"
    "MIIBCgKCAQEAvKLEOWTzt9Hn3/9Kdp/RdHcEhzmd8xXeLSpHIIzaXTLJDw8BhJy1\n"
    "jR/iqeG8Je5yrtVabqMSkA6ltIpgylH///FojMsX1BHu4EPYOXQgB0qOi6kr08iX\n"
    "ZIH9/iOPQOWDsL+Lt8gDG0xBy+sPe/2ZHdzKMjX6O9B4sOsxjFrk5qDoWDrioJor\n"
    "AJ7eFAfPpOBf2w73ohXudSrJE0lbQ8pCWNpMY8cB9i8r+WBitcvouLDAvmtnTX7a\n"
    "khoDzmKgpJBYliAY4qA73v7u5UIepE8QgV0jCOhxJCPubP8dg+/PlLLVKyxU5Cdi\n"
    "QtZj2EMy4s9xlNKzX8XezE0MHEa6bQpnFwIDAQAB\n"
    "-----END RSA PUBLIC KEY-----\n";

// 	fingerprint uint64 = 12240908862933197005

uint64_t computeFingerprint(const char* key_data, int key_data_len) {
    BIO *key_bio = BIO_new(BIO_s_mem());
    BIO_write(key_bio, key_data, key_data_len);
    RSA *rsa_key = PEM_read_bio_RSAPublicKey(key_bio, NULL, NULL, NULL);
    BIO_free(key_bio);
    unsigned int n_size = BN_num_bytes(rsa_key->n);
    unsigned int e_size = BN_num_bytes(rsa_key->e);

    std::cout << "n_size: " << n_size << ", e_size: " << e_size << std::endl;

    unsigned char* tmp = new unsigned char[n_size + e_size];
    BN_bn2bin(rsa_key->n, tmp);
    BN_bn2bin(rsa_key->e, tmp + n_size);
    RSA_free(rsa_key);

    std::vector<unsigned char> obuf;
    WriteString(tmp, n_size, obuf);
    WriteString(tmp+n_size, e_size, obuf);

    std::cout << "obuf size: " << obuf.size() << std::endl;
    delete []tmp;

    uint8_t sha1_digest[20];
    SHA1(obuf.data(), obuf.size(), sha1_digest);

    PringHex(obuf.data(), obuf.size());
    PringHex(sha1_digest, 20);

    // 最后8个字节的uint64值为fingerprint
    return *(uint64_t*)(sha1_digest + 12);
}

void TestIsGoodPrime() {
    // check prime
    BIGNUM *p = BN_bin2bn(kDH2048P, 256, NULL);
    if (p == nullptr) {
        std::cerr << "can't allocate BIGNUM p" << std::endl;
        exit(1);
    }

    if (check_prime(p) == false) {
        std::cerr << "check_prime(p) error!" << std::endl;
        BN_free(p);
        // return 0;
    }

    if (!isGoodPrime(p, 2)) {
        std::cerr << "bad prime" << std::endl;
        BN_free(p);
        // return 0;
    }

    BN_free(p);
}

static std::string serverPublicKeys =
    "-----BEGIN RSA PUBLIC KEY-----\n"
    "MIIBCgKCAQEAwVACPi9w23mF3tBkdZz+zwrzKOaaQdr01vAbU4E1pvkfj4sqDsm6\n"
    "lyDONS789sVoD/xCS9Y0hkkC3gtL1tSfTlgCMOOul9lcixlEKzwKENj1Yz/s7daS\n"
    "an9tqw3bfUV/nqgbhGX81v/+7RFAEd+RwFnK7a+XYl9sluzHRyVVaTTveB2GazTw\n"
    "Efzk2DWgkBluml8OREmvfraX3bkHZJTKX4EQSjBbbdJ2ZXIsRrYOXfaA+xayEGB+\n"
    "8hdlLmAjbCVfaigxX0CDqWeR1yFL9kwd9P0NsZRPsmoqVwMbMu7mStFai6aIhc3n\n"
    "Slv8kg9qv1m6XHVQY3PnEw+QQtqSIXklHwIDAQAB\n"
    "-----END RSA PUBLIC KEY-----\n";
// serverPublicKeysFingerprints.push_back(0xc3b42b026ce86b21LL);


static std::string serverPublicKeys2 =
    "-----BEGIN RSA PUBLIC KEY-----\n"
    "MIIBCgKCAQEAvKLEOWTzt9Hn3/9Kdp/RdHcEhzmd8xXeLSpHIIzaXTLJDw8BhJy1\n"
    "jR/iqeG8Je5yrtVabqMSkA6ltIpgylH///FojMsX1BHu4EPYOXQgB0qOi6kr08iX\n"
    "ZIH9/iOPQOWDsL+Lt8gDG0xBy+sPe/2ZHdzKMjX6O9B4sOsxjFrk5qDoWDrioJor\n"
    "AJ7eFAfPpOBf2w73ohXudSrJE0lbQ8pCWNpMY8cB9i8r+WBitcvouLDAvmtnTX7a\n"
    "khoDzmKgpJBYliAY4qA73v7u5UIepE8QgV0jCOhxJCPubP8dg+/PlLLVKyxU5Cdi\n"
    "QtZj2EMy4s9xlNKzX8XezE0MHEa6bQpnFwIDAQAB\n"
    "-----END RSA PUBLIC KEY-----";

void TestComputeFingerprint() {
    uint64_t v = computeFingerprint(g_test_public_key.c_str(), (int)g_test_public_key.length());
    std::cout << "Fingerprint: " << v << std::endl;
}

void TestComputeFingerprint2() {
    uint64_t v = computeFingerprint(serverPublicKeys.c_str(), (int)serverPublicKeys.length());
    std::cout << "Fingerprint: " << v << std::endl;
}

void TestComputeFingerprint3() {
    uint64_t v = computeFingerprint(serverPublicKeys2.c_str(), (int)serverPublicKeys2.length());
    std::cout << "Fingerprint: " << v << std::endl;
}

void TestGA() {
    BN_CTX* bn_context = BN_CTX_new();
    BIGNUM* p = BN_bin2bn(kDH2048P, 256, NULL);

    BIGNUM *g = BN_new();
    BN_set_word(g, kDH2048G[0]);

    uint8_t bytes[256];
    RAND_bytes(bytes, 256);
    BIGNUM* a = BN_bin2bn(bytes, 256, NULL);

    BIGNUM *g_a = BN_new();

    // auto bn_context = BN_CTX_new();
    BN_mod_exp(g_a, g, a, p, bn_context);

    // auto g_a_data_size = BN_num_bytes(g_a);
    // uint8_t g_a_data = new uint8_t(g_a_data_size);
    // BN_bn2bin(g_a, g_a_data);
    if (!isGoodGaAndGb(g_a, p)) {
        std::cerr << "isGoodGaAndGb(g_a, p) false" << std::endl;
    } else {
        std::cout << "isGoodGaAndGb(g_a, p) true" << std::endl;
    }

    BN_free(g);
    BN_free(g_a);
    BN_CTX_free(bn_context);
}

int main(int argc, char* argv[]) {
    // if (bnContext == nullptr) {
    //     bnContext = BN_CTX_new();
    // }

    // TestIsGoodPrime();
    // TestComputeFingerprint();
    // TestComputeFingerprint2();
    // TestComputeFingerprint3();
    TestGA();

    return 0;
}